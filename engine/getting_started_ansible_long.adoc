:scrollbar:
:data-uri:
:toc: left
:numbered:
:icons: font

// Tested with BP EMEA-PARTNERS-Ansible_Tower32_rhpds-long-0.3.6.1-bp

== Your Lab Environment

You will work in a lab environment that has already been deployed for you.

You will have access to the following hosts:

|===
|Hostname|Internal IP|Role
|control.example.com|192.168.0.10|The host you will run Ansible on to manage the other hosts. Only this host is accessible from the Internet.
|host1.example.com|192.168.0.20|Managed host1
|host2.example.com|192.168.0.30|Managed host2
|===

WARNING: You will be able to SSH into the control host, from here you need to SSH into the other hosts.

== Access the Lab Environment

include::access_event.adoc[]

== Ansible Deployment

In this lab you configure `control.example.com` as Ansible control node to manage your  hosts `host1.example.com` and `host2.example.com`. You begin by verifying that the prerequisite software is installed on both the control node and the managed hosts and that the hosts can communicate successfully over SSH.

=== Install Ansible

* Log in as the `root` user on `control.example.com` and install Ansible:
-----
[root@control ~]# yum install ansible -y
-----

TIP: In this lab the needed packages are mirrored locally, in real life you need to enable the required repos.

TIP: For some time in order to use Ansible on RHEL you had to install it from the EPEL repository. This has changed, but you still have some options to get Ansible on RHEL: If you have a Red Hat Ansible Engine Subscription (the supported version of Ansible), you'll have access to a dedicated Ansible repo, if you are a RHEL only Customer you need to enable the RHEL Extras repository. Apart from this RPMs of Ansible Engine are available from releases.ansible.com. Please see the following Red Hat KB article for more details: RPMs of Ansible Engine releases are available from releases.ansible.com.

* Check Ansible has been installed correctly
----
[root@control ~]# ansible --version
ansible 2.5.0
  config file = /etc/ansible/ansible.cfg
  [...]
----

NOTE: Ansible is keeping configuration management simple. Ansible requires no database or running daemons and can run easily on a laptop. On the managed hosts it needs no running agent.

=== Set up users and SSH

In the lab exercises Ansible connects to the managed hosts by SSH using key authentication. You need to set up the nodes correctly before proceeding. Later we'll run Ansible commands that require root privileges. As we don't want to run Ansible as root you have to setup sudo to enable privilege escalation on the managed nodes.

TIP: User ansible has already been setup for you on all nodes with the same password as root.

To enable key authenticated SSH logins without password:

* Become user ansible on the control node and create an SSH key without password protection:
----
[root@control ~]# su - ansible
[ansible@control ~]$ ssh-keygen
----

* Copy the SSH key to the managed nodes (password is the same as root on all nodes):
----
[ansible@control ~]$ ssh-copy-id host1.example.com
[ansible@control ~]$ ssh-copy-id host2.example.com
----

* Verify that the managed hosts now accept password-less connections with key authentication from the control node as user ansible.
----
[ansible@control ~]$ ssh host1.example.com
[ansible@control ~]$ ssh host2.example.com
----

=== Setup sudo

To allow user ansible to execute commands on host1 and host2 as root you have to configure `sudo` on the managed nodes:

* From the control node login as root to host1.example.com.
* Use `visudo` to edit the sudoers file. Uncomment the line that allows people in group wheel to run all commands without password and comment the line that makes them require a password:
----
## Allows people in group wheel to run all commands
#%wheel ALL=(ALL)       ALL

## Same thing without a password
%wheel  ALL=(ALL)       NOPASSWD: ALL
----

* Save your changes

* Add user ansible to the `wheel` group:
----
[root@host1 ~]# usermod -aG wheel ansible
----

* Test that the updated configuration allows ansible to run commands using sudo:
----
[root@host1 ~]# su - ansible
[ansible@host1 ~]$ sudo cat /etc/shadow
----

* When finished, exit the SSH session to host1 and repeat the steps for host2.example.com.
* After configuration of host2.example.com, do a final test to check if you can:
** run commands over SSH
** without password
** using sudo

----
[ansible@control ~]$ ssh -t host1.example.com "sudo cat /etc/shadow"
----

TIP: In real world environments you would integrate these steps into you deployment process so your nodes are already configured for using Ansible over SSH.

NOTE: In all subsequent exercises you should work as the ansible user on the control node if not explicitly told differently.

=== Working the Labs

You might have guessed by now this lab is pretty commandline-centric... :-)

* Don't type everything manually, use copy & paste from the browser when appropriate. But don't stop to think and understand... ;-)
* All labs where prepared using Vi, but feel free to install nano or even emacs.

TIP: In the lab guide commands you are supposed to run are shown with or without the expected output, whatever makes more sense in the context.

TIP: The command line can wrap on the web page from time to time. Therefor the output is separated from the command line for better readability by an empty line. *Anyway, the line you should actually run should be recognizable by the prompt.* :-)

=== Challenge Labs

You will soon discover that many chapters in this lab guide come with a "Challenge Lab" section. These labs are meant to give you a small task to solve using what you have learned so far. The solution of the task is shown underneath a warning sign.

== Getting Started with Ansible

=== The Inventory

To use the ansible command for host management, you need to provide an inventory file which defines a list of hosts to be managed from the control node. One way to do this is to specify the path to the inventory file with the `-i` option to the ansible command.

Make sure you are user ansible on control.example.com. Create a directory for your Ansible files:
----
[ansible@control ~]$ mkdir ansible-files
----

TIP: This is a project directory, you could of course name it like you want.

Now create a simple inventory file as `~/ansible-files/inventory` with the following content:
----
host1.example.com
host2.example.com
----

To reference inventory hosts, you supply a host pattern to the ansible command. Ansible has a `--list-hosts` option which can be useful for clarifying which managed hosts are referenced by the host pattern in an ansible command.

The most basic host pattern is the name for a single managed host listed in the inventory file. This specifies that the host will be the only one in the inventory file that will be acted upon by the ansible command. Run:

----
[ansible@control ~]$ ansible "host1.example.com" -i ~/ansible-files/inventory --list-hosts

  hosts (1):
    host1.example.com
----

An inventory file can contain a lot more information. To organize your hosts in groups, change your inventory file so it looks like this:
----
[webserver]
host1.example.com

[database]
host2.example.com

[ftpserver]
host2.example.com
----

Now run Ansible with these host patterns and observe the output:
----
[ansible@control ~]$ ansible webserver -i ~/ansible-files/inventory --list-hosts
[ansible@control ~]$ ansible webserver,host2.example.com -i ~/ansible-files/inventory --list-hosts
[ansible@control ~]$ ansible '*.example.com' -i ~/ansible-files/inventory --list-hosts
[ansible@control ~]$ ansible all -i ~/ansible-files/inventory --list-hosts
----

TIP: It is ok to put systems in more than one group, for instance a server could be both a web server and a database server.

TIP: The inventory can contain more data. E.g. if you have hosts that run on non-standard SSH ports you can put the port number after the hostname with a colon. Or you could define names specific to Ansible and have them point to the "real" IP or hostname.

=== The Ansible Configuration Files

The behavior of Ansible can be customized by modifying settings in Ansible's ini-style configuration file. Ansible will select its configuration file from one of several possible locations on the control node, please refer to the documentation.

TIP: The recommended practice is to create an `ansible.cfg` file in a directory from which you run Ansible commands. This directory would also contain any files used by your Ansible project, such as the inventory and Playbooks.

Make sure your inventory file is used by default when executing commands from the `~/ansible-files/` directory:

* On control.example.com as ansible create the file `~/ansible-files/ansible.cfg` with the following content:
----
[defaults]
inventory=/home/ansible/ansible-files/inventory
----

* Check with `ansible --version`, first from ansible's home directory and then from `~/ansible-files/`. You should find when run from `~/ansible-files/` your personal config settings override the main config file.
* From `~/ansible-files/` run `ansible all --list-hosts`.

Your Ansible inventory was used without providing the `-i` option. To double-check, run the command again from outside `~/ansible-files/`:

----
[ansible@control ansible-files]$ cd ..
[ansible@control ~]$ ansible all --list-hosts

 [WARNING]: provided hosts list is empty, only localhost is available

 [WARNING]: No hosts matched, nothing to do

  hosts (0):
----

== Running Ansible Ad-Hoc Commands

Ansible allows administrators to execute on-demand tasks on managed hosts. These ad hoc commands are the most basic operations that can be performed with Ansible. They are great for learning about Ansible, for trying new things or for quick non-intrusive tasks like reporting. Let's try something straight forward:

WARNING: *Don't forget to run the commands from `~/ansible-files/` where your `ansible.cfg` file is located, otherwise it will complain about an empty host list.*

Run the examples on control.example.com from the `~/ansible-files/` directory as user ansible.
----
[ansible@control ansible-files]$ ansible all -m ping
----

The `-m` option defines which Ansible module to use. Options can be passed to the specified modul using the `-a` option. BTW the `ping` module is not running an ICMP ping but does a simple connection test.

TIP: Think of a module as a tool which is designed to accomplish a specific task.

=== Listing Modules and Getting Help

Modules are programs that Ansible uses to perform operations on managed hosts. They are
ready-to-use tools designed to perform specific operations. Modules can be executed from the commandline as Ansible ad hoc commands or used in Playbooks to execute tasks. When run, modules are copied to the managed host and executed there.

To list all modules run:

----
[ansible@control ansible-files]$ ansible-doc -l
----

TIP: In `ansible-doc` use the `up`/`down` arrows to scroll through the content and leave with `q`.

To find a module try e.g.:
----
[ansible@control ansible-files]$ ansible-doc -l | grep -i user
----

Get help for a specific module including usage examples:
----
[ansible@control ansible-files]$ ansible-doc user
----

TIP: This will give all options ("=" shows a mandatory option), examples for usage and occasionally some notes.

=== More Ad Hoc Commands

Let's try a simple module that just executes a command on a managed host:
----
[ansible@control ansible-files]$ ansible host1.example.com -m command -a 'id'

host1.example.com | SUCCESS | rc=0 >>
uid=1000(ansible) gid=1000(ansible) groups=1000(ansible),10(wheel) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
----

In this case the module is called `command` and the option passed with `-a` is the actual command to run. Try to run this ad hoc command on both hosts using the `all` host pattern.

Another example: Have a quick look at the kernel versions your hosts are running:
----
[ansible@control ansible-files]$ ansible all -m command -a 'uname -r'
----

Sometimes it's desirable to have the output for a host on one line:
----
[ansible@control ansible-files]$ ansible all -m command -a 'uname -r' -o
----

Using the `copy` module, execute an ad hoc command on control.example.com to change the contents of the `/etc/motd` file on host1.example.com. *The content is handed to the module through an option in this case*.

Run:

----
[ansible@control ansible-files]$ ansible host1.example.com -m copy -a 'content="Managed by Ansible\n" dest=/etc/motd'
----
Output:
----
host1.example.com | FAILED! => {
    "changed": false,
    "checksum": "a314620457effe3a1db7e02eacd2b3fe8a8badca",
    "failed": true,
    "msg": "Destination /etc not writable"
}

----

Should be all red for you, the ad hoc command failed. Why? Because user ansible is not allowed to write the motd file.

Now this is a case for privilege escalation and the reason `sudo` has to be setup properly. We need to instruct ansible to use `sudo` to run the command as root by using the parameter `-b` (think "become").

TIP: Ansible will connect to the machines using your current user name (ansible in this case), just like SSH would. To override the remote user name, you could use the `-u` parameter.

For us it's okay to connect as ansible because `sudo` is set up. Change the command to use the `-b` parameter and run again:
----
[ansible@control ansible-files]$ ansible host1.example.com -m copy -a 'content="Managed by Ansible\n" dest=/etc/motd' -b
----
Output:
----
host1.example.com | SUCCESS => {
    "changed": true,
    "checksum": "a314620457effe3a1db7e02eacd2b3fe8a8badca",
    "dest": "/etc/motd",
    "gid": 0,
    "group": "root",
    "md5sum": "7a924f6b4cbcbc7414eda7763dc0e43b",
    "mode": "0644",
    "owner": "root",
    "secontext": "system_u:object_r:etc_t:s0",
    "size": 19,
    "src": "/home/ansible/.ansible/tmp/ansible-tmp-1472132609.82-261447806330276/source",
    "state": "file",
    "uid": 0
}
----

Check the motd file:
----
[ansible@control ansible-files]$ ansible host1.example.com -m command -a 'cat /etc/motd'

host1.example.com | SUCCESS | rc=0 >>
Managed by Ansible
----

Run the `ansible host1.example.com -m copy ...` command from above again. Note:

* the different output color (proper terminal config provided)
* the change from `"changed": true,` to `"changed": false,`.

TIP: This makes it a lot easier to spot changes and what Ansible actually did.

=== Challenge Lab: Modules

* Using `ansible-doc`
** Find a module that uses Yum to manage software packages.
** Look up the help examples for the module to learn how to install a package in the latest version
* Run an Ansible ad hoc command to install the package "screen" in the latest version on host1.example.com

TIP: Use the copy ad hoc command from above as a template and change the module and options.

WARNING: *Solution below!*

----
[ansible@control ansible-files]$ ansible-doc -l | grep -i yum
[ansible@control ansible-files]$ ansible-doc yum
[ansible@control ansible-files]$ ansible host1.example.com -m yum -a 'name=screen state=latest' -b
----

== Ansible Playbooks

While Ansible ad hoc commands are useful for simple operations, they are not suited for complex configuration management or orchestration scenarios.

Playbooks are files which describe the desired configurations or steps to implement on managed hosts. Playbooks can change lengthy, complex administrative tasks into easily repeatable routines with predictable and successful outcomes.

TIP: Here is a nice analogy: When Ansible modules are the tools in your workshop, the inventory is the materials and the Playbooks are the instructions.

=== Playbook Basics

Playbooks are text files written in YAML format and therefore need:

* to start with three dashes (`---`)
* proper identation using spaces and *not* tabs!

There are some important concepts:

* *hosts*: the managed hosts to perform the tasks on
* *tasks*: the operations to be performed by invoking Ansible modules and passing them the necessary options.
* *become*: privilege escalation in Playbooks, same as using `-b` in the ad hoc command.

WARNING: The ordering of the contents within a Playbook is important, because Ansible executes plays and tasks in the order they are presented.

A Playbook should be *idempotent*, so if a Playbook is run once to put the hosts in the correct state, it should be safe to run it a second time and it should make no further changes to the hosts.

TIP: Most Ansible modules are idempotent, so it is relatively easy to ensure this is true.

TIP: Try to avoid the command, shell, and raw modules in Playbooks. Because these take arbitrary commands, it is very easy to end up with non-idempotent Playbooks with these modules.

=== Playbook Example

And here is a simple example of a Playbook:
----
---
# simple playbook with a single play
- name: a simple play
  hosts: managedhost.example.com
  user: remoteuser
  become: yes
  become_method: sudo
  become_user: root
  # First a name for the task, second entry invokes the service module and supplies its
arguments.
  tasks:
  - name: first task
    service: name=httpd enabled=true
  - name: second task
    service: name=sshd enabled=true
----

== Your first Playbook

Enough theory, it's time to create your first Playbook. In this lab you create a Playbook to set up an Apache webserver in three steps:

* First step: Install httpd package
* Second step: Enable/start httpd service
* Third step: Create an index.html file

=== Playbook: Install Apache

This Playbook makes sure the package containing the Apache webserver is installed on host1.example.com.

TIP: You obviously need to use privilege escalation to install a package or run any other task that requires root permissions. This is done in the Playbook by `become: yes`.

On control.example.com as user ansible create the file `~/ansible-files/apache.yml` with the following content:
----
---
- name: Apache server installed
  hosts: host1.example.com
  become: yes
  tasks:
  - name: latest Apache version installed
    yum:
      name: httpd
      state: latest
----

This shows one of Ansible's strenghts: The Playbook syntax is easy to read and understand. In this Playbook:

* A name is given for the play
* The host to run against and privilege escalation is configured
* A task is defined and named, here it uses the module "yum" with the needed options.

=== Running Playbooks

Playbooks are executed using the `ansible-playbook` command on the control node. Before you run a new Playbook it's a good idea to check for syntax errors:
----
[ansible@control ansible-files]$ ansible-playbook --syntax-check apache.yml
----

Now you should be ready to run your Playbook:
----
[ansible@control ansible-files]$ ansible-playbook apache.yml
----

Use SSH to make sure Apache has been installed on host1.example.com.

----
[ansible@control ansible-files]$ ssh host1.example.com rpm -qi httpd

Name        : httpd
Version     : 2.4.6
[...]
----

Or even better use an Ansible ad hoc command!

----
[ansible@control ansible-files]$ ansible host1.example.com -m command -a 'rpm -qi httpd'
----

Run the Playbook a second time.

TIP: The different colors, the "ok" and "changed" counters and the "PLAY RECAP" make it easy to spot what Ansible actually did.

=== Extend your Playbook: Start & Enable Apache

The next part of the Playbook makes sure the Apache webserver is enabled and started on host1.example.com.

On control.example.com as user ansible edit the file `~/ansible-files/apache.yml` to add a second task using the `service` module. The Playbook should now look like this:
----
---
- name: Apache server installed
  hosts: host1.example.com
  become: yes
  tasks:
  - name: latest Apache version installed
    yum:
      name: httpd
      state: latest
  - name: Apache enabled and running
    service:
      name: httpd
      enabled: true
      state: started
----

And again what it does is easy to understand:

* a second task is defined
* a module is specified (`service`)
* options are supplied

WARNING: As this is YAML take care of the correct indentation when copy/pasting!

Run your extended Playbook:
----
[ansible@control ansible-files]$ ansible-playbook apache.yml
----

* Note some tasks are shown as "ok" in green and one is shown as "changed" in yellow.
* Use an Ansible ad hoc command again to make sure Apache has been enabled and started, e.g.: `systemctl status httpd`

=== Extend your Playbook: Create an index.html

Check that the tasks were executed correctly and Apache is accepting connections: Make an HTTP request using Ansible's `uri` module in an ad hoc command from the control node:
----
[ansible@control ansible-files]$ ansible localhost -m uri -a "url=http://host1.example.com/"
----

WARNING: Expect a lot of red lines and a 403 status!

As long as there is not at least an `index.html` file to be served by Apache, it will throw an ugly "HTTP Error 403: Forbidden" status and Ansible will report an error.

So why not use Ansible to deploy a simple `index.html` file? Create the file `~/ansible-files/index.html` on the control node:
----
<body>
<h1>Apache is running fine</h1>
</body>
----

You already used Ansible's `copy` module to write text supplied on the commandline into a file. Now you'll use the module in your Playbook to actually copy a file:

On control.example.com as user ansible edit the file `~/ansible-files/apache.yml` and add a new task utilizing the `copy` module. It should now look like this:
----
---
- name: Apache server installed
  hosts: host1.example.com
  become: yes
  tasks:
  - name: latest Apache version installed
    yum:
      name: httpd
      state: latest
  - name: Apache enabled and running
    service:
      name: httpd
      enabled: true
      state: started
  - name: copy index.html
    copy:
      src: ~/ansible-files/index.html
      dest: /var/www/html/
----

You are getting used to the Playbook syntax, so what happens? The new task uses the `copy` module and defines the source and destination options for the copy operation.

Run your extended Playbook:
----
[ansible@control ansible-files]$ ansible-playbook apache.yml
----

* Have a good look at the output
* Run the ad hoc command using the "uri" module to test Apache again.

The command should now return a friendly green "status: 200" line, amongst other information.

=== Challenge Lab: Playbooks

* Change the apache.yml Playbook to run on host1 *and* host2.example.com.

TIP: There are multiple ways to do this, try to edit the "webserver" group in your inventory file to include both hosts and change your Playbook to use the group in `hosts:`

* Run the Playbook
* Test using the ad hoc command with the `uri` module.

WARNING: *Solution below!*

The changed inventory file:
----
[webserver]
host1.example.com
host2.example.com

[database]
host2.example.com

[ftpserver]
host2.example.com
----

The Playbook now pointing to the group "webserver":
----
---
- name: Apache server installed
  hosts: webserver
  become: yes
  tasks:
  - name: latest Apache version installed
    yum:
      name: httpd
      state: latest
  - name: Apache enabled and running
    service:
      name: httpd
      enabled: true
      state: started
  - name: copy index.html
    copy:
      src: ~/ansible-files/index.html
      dest: /var/www/html/
----

Run the Playbook:
----
[ansible@control ansible-files]$ ansible-playbook apache.yml
----

And the commands to check if Apache is now running on both servers:
----
[ansible@control ansible-files]$ ansible localhost -m uri -a "url=http://host1.example.com/"
----
----
[ansible@control ansible-files]$ ansible localhost -m uri -a "url=http://host2.example.com/"
----

== Ansible Variables

=== Introduction

Ansible supports variables to store values that can be used in Playbooks. Variables can be defined in a variety of places and have a clear precedence. Ansible substitutes the variable with its value when a task is executed.

*Variables are referenced in Playbooks by placing the variable name in double curly braces.*
----
Here comes a variable {{ variable1 }}
----

The recommended practice is to define variables in files located in two directories named `host_vars` and `group_vars`:

* To e.g. define variables for a group "servers", create a YAML file named `group_vars/servers` with the variable definitions.

* To define variables specifically for a host "host1.example.com", create the file `host_vars/host1.example.com` with the variable definitions.

TIP: Host variables take precedence over group variables (more about precedence can be found in the docs).

=== Variables in Playbooks

==== Defining Variables in Playbooks

Administrators can define their own variables in Playbooks and use them in tasks. Playbook variables can be defined in multiple ways.

* Place it directly in a vars block at the beginning of a Playbook:
----
- hosts: all
  vars:
    user: joe
    home: /home/joe
----

* Define Playbook variables in external files:
----
- hosts: all
  vars_files:
    - vars/users.yml
----

The Playbook variables are then defined in that file in YAML format:
----
---
user: joe
home: /home/joe
----

=== Off to the Lab

For understanding and practice let's do a lab. Following up on the theme "Let's build a webserver. Or two. Or even more..." you will change the `index.html` to show the development environment (dev/prod) a server is deployed in.

On control.example.com as user ansible create the directories to hold the variable definitions in `~/ansible-files/`:

----
[ansible@control ansible-files]$ mkdir {host_vars,group_vars}
----

=== Create the Variable Files

Now create two files containing variable definitions which point to an environment:

* `~/ansible-files/group_vars/webserver` with this content:
----
---
stage: dev
----

* `~/ansible-files/host_vars/host2.example.com`, content:
----
---
stage: prod
----

What is this about?

* All servers in the `webserver` group are defined as members of the dev environment by default.
* For server "host2.example.com" this is overriden and the host is flagged as a production server.

=== Create index.html Files

Now create two files in `~/ansible-files/`:

One called `prod_index.html` with the following content:
----
<body>
<h1>This is a production webserver, take care!</h1>
</body>
----

And the other called `dev_index.html` with the following content:
----
<body>
<h1>This is a development webserver, have fun!</h1>
</body>
----

=== Create the Playbook

Now you need a Playbook that copies the prod or dev index.html file according to the "stage" variable.

Create a new Playbook called `deploy_index_html.yml` in the `~/ansible-files/` directory.

TIP: Note how the variable "stage" is used in the name of the file to copy.

----
---
- name: Copy index.html
  hosts: webserver
  become: yes
  tasks:
  - name: copy index.html
    copy:
      src: ~/ansible-files/{{ stage }}_index.html
      dest: /var/www/html/index.html
----

* Run the Playbook:
----
[ansible@control ansible-files]$ ansible-playbook deploy_index_html.yml
----

=== Test the Result

The Playbook should copy different files as index.html to the hosts, use `curl` to test it:
----
[ansible@control ansible-files]$ curl http://host1.example.com

<body>
<h1>This is a development webserver, have fun!</h1>
</body>
----
----
[ansible@control ansible-files]$ curl http://host2.example.com

<body>
<h1>This is a production webserver, take care!</h1>
</body>
----

TIP: If by now you think: There has to be a smarter way to change content in files... you are absolutely right. This lab was done to introduce variables, you are about to learn about templates in one of the next labs.

=== Challenge Lab: Using Inventory Variables

A lab just for you without a lot of help... you should by now have all information to complete the follwing tasks:

* In the variable file for the group `webserver` set a variable *service* to *sshd*.
* In the host variable file for host `host2.example.com` set the variable *service* to *httpd*.
* Create a Playbook `check_service.yml` to restart a service which name is defined by a variable *service*. Make it applicable to both hosts.
* Run the Playbook with "-v" to see Ansible is actually checking different services according to the variables.

WARNING: *Solution below!*

----
[ansible@control ansible-files]$ cat host_vars/host2.example.com
---
stage: prod
service: httpd
----
----
[ansible@control ansible-files]$ cat group_vars/webserver
---
stage: dev
service: sshd
----
----
[ansible@control ansible-files]$ cat check_service.yml
---
- name: Check if  service is enabled and started
  hosts: host*.example.com
  become: yes
  tasks:
  - name: Check service is enabled and started
    service:
      name: "{{ service }}"
      enabled: true
      state: restarted

[ansible@control ansible-files]$ ansible-playbook check_service.yml -v
----

=== Registered variables

Administrators can capture the output of a command by using the register statement. The
output is saved into a variable that could be used later for either debugging purposes or in order
to achieve something else, such as a particular configuration based on a command's output.

The following Playbook demonstrates the use, create it as `register_var.yml` and run it:
----
---
- name: Installs a package and prints the result
  hosts: host1.example.com
  tasks:
    - name: Install the package
      yum:
        name: httpd
        state: installed
      register: install_result
    - debug: var=install_result
----

When this Playbook is run:

* the debug module is used to dump the value of the install_result
registered variable to the terminal.

This can be very useful while debugging, we'll cover more of this later. In this case the package was already installed which is mirrored by the module output captured in the variable.

== Ansible Facts

Ansible facts are variables that are automatically discovered by Ansible from a managed host. Facts are pulled by the `setup` module and contain useful information stored into variables that administrators can reuse.

To get an idea what facts Ansible collects by default, on control.example.com as user ansible from the `~/ansible-files/` directory run:

----
[ansible@control ansible-files]$ ansible host1.example.com -m setup
----

TIP: You still remember why you have to run ansible from this directory?

This might be a bit too much, you can use filters to limit the output to certain facts, the expression is shell-style wildcard:
----
[ansible@control ansible-files]$ ansible host1.example.com -m setup -a 'filter=ansible_eth0'
----

Or what about only looking for memory related facts:
----
[ansible@control ansible-files]$ ansible all -m setup -a 'filter=ansible_*_mb'
----

=== Challenge Lab: Facts

* Try to find and print the distribution (Red Hat) of your managed hosts. On one line, please.

TIP: Use grep to find the fact, then apply a filter to only print this fact.

WARNING: *Solution below!*

----
[ansible@control ansible-files]$ ansible host1.example.com -m setup | grep distribution
----
----
[ansible@control ansible-files]$ ansible all -m setup -a 'filter=ansible_distribution' -o
----

=== Using Facts in Playbooks

Facts can be used in a Playbook like variables, using the proper naming, of course. Create this Playbook as `facts.yml` in the `~/ansible-files/` directory:
----
---
- name: Output facts within a playbook
  hosts: all
  tasks:
  - name: Prints Ansible facts
    debug:
      msg: The default IPv4 address of {{ ansible_fqdn }} is {{ ansible_default_ipv4.address }}
----

TIP: The "debug" module is handy for e.g. debugging variables or expressions.

Execute it to see how the facts are printed:
----
[ansible@control ansible-files]$ ansible-playbook facts.yml

PLAY [all] *********************************************************************

TASK [setup] *******************************************************************
ok: [host1.example.com]
ok: [host2.example.com]

TASK [Prints various Ansible facts] ********************************************
ok: [host1.example.com] => {
    "msg": "The default IPv4 address of host1.example.com is 192.168.0.20\n"
}
ok: [host2.example.com] => {
    "msg": "The default IPv4 address of host2.example.com is 192.168.0.30\n"
}

PLAY RECAP *********************************************************************
host1.example.com          : ok=2    changed=0    unreachable=0    failed=0
host2.example.com          : ok=2    changed=0    unreachable=0    failed=0
----

=== Custom Facts

But Ansible wouldn't be Ansible if facts could not be extended with own facts. Ansible looks for custom facts on managed nodes in `/etc/ansible/facts.d/`. Files containing fact definitions must have `.fact` as an extension. A facts file is a plain-text file in INI or JSON format. For both formats, the result returned by Ansible is the same and will be put in the ansible_local level.

To use custom facts:

* A facts file must exist on a managed node.
* After Ansible finds the custom facts, they can be used like regular facts.

What better then to have Ansible create the facts file on a host? But you could of course put it there using other mechanisms (e.g. Kickstart) as well.

* Create a file `custom.fact` with the following content in your `~/ansible-files/` directory:
----
[general]
package = httpd
service = httpd
state = started
----

* Create a `setup_facts.yml` Playbook to create the directory and copy the file to the managed nodes:
----
---
- name: Install remote facts
  hosts: host1.example.com
  vars:
    remote_dir: /etc/ansible/facts.d
    facts_file: custom.fact
  tasks:
    - name: Create the remote directory
      file:
        state: directory
        recurse: yes
        path: "{{ remote_dir }}"
    - name: Install the new facts
      copy:
        src: "{{ facts_file }}"
        dest: "{{ remote_dir }}"
----

Understand everything the Playbook does:

* The host to run on is defined
* Variables are defined
* Two tasks are defined, the first makes sure the fact directory exists, the second copies the fact file

Before running the Playbook, have a look at the facts in the ansible_local level, it should be empty:
----
[ansible@control ansible-files]$ ansible host1.example.com -m setup -a 'filter=ansible_local'
host1.example.com | SUCCESS => {
    "ansible_facts": {},
    "changed": false
}
----

Now run the Playbook to make the custom facts available on host1:
----
[ansible@control ansible-files]$ ansible-playbook setup_facts.yml
----

Uhhh, that didn't look good, lots of errors. But you should by now know whats missing in the Playbook, fix and run it again (hint: privileges). After a successful run the custom facts directory and the fact file are available on the node.

Run the Ansible command to query the custom facts again:
----
[ansible@control ansible-files]$ ansible host1.example.com -m setup -a 'filter=ansible_local'
host1.example.com | SUCCESS => {
    "ansible_facts": {
        "ansible_local": {
            "custom": {
                "general": {
                    "package": "httpd",
                    "service": "httpd",
                    "state": "started"
                }
            }
        }
    },
    "changed": false
}
----

You can see how your custom facts are now integrated in the facts output and how the section title ("general") from your facts file is integrated as well.

As an example of how custom facts can be used, create and run the following Playbook as `use_facts.yml`:
----
---
- name: Install package named by fact and start the service
  hosts: host1.example.com
  become: yes
  tasks:
   - name: Install the required package
     yum:
       name: "{{ ansible_local.custom.general.package }}"
       state: latest
   - name: Start the service
     service:
       name: "{{ ansible_local.custom.general.service }}"
       state: "{{ ansible_local.custom.general.state }}"
----

Of course there should be no changes because Apache was already installed and running. But you can see how you could use your custom facts as variables in a Playbook.

== Controlling Task Execution

=== Loops

Often you’ll want to do many things in one task, such as

* create a lot of users
* install a lot of packages
* repeat a polling step until a certain result is reached.

Ansible supports loops to iterate over a set of values and saves administrators from writing repetitive tasks that use the same module.

Ansible supports three types of loops: simple loops, list of hashes and nested loops. In this lab we'll have a quick look at the first two.

WARNING: Ansible 2.5 brought a new and easier way do work with loops: The `loop` keyword. Before 2.5 Ansible mainly used the `with_<lookup>` keywords to create loops, the new `loop` keyword is basically analogous to `with_list`. You'll find a lot of Ansible examples using `with_items` or `with_nested` on the Internet.

==== Simple Loops

Simple loops are a list of items that Ansible iterates over. They are
defined by providing a list of items to the `loop` keyword. Create the following Playbook and run it:
----
---
- name: Loop demo
  hosts: host1.example.com
  tasks:
    - name: Check if service is started
      service:
        name: "{{ item }}"
        state: started
      loop:
        - httpd
        - sshd
----

The list of items to loop over could also be supplied as an array in the vars section or in a file. In this example the array is called `check_services`. Create this Playbook and run it:
----
---
- name: Loop demo
  hosts: host1.example.com
  vars:
    check_services:
      - httpd
      - sshd
  tasks:
    - name: Check if service is started
      service:
        name: "{{ item }}"
        state: started
      loop: "{{ check_services }}"
----


==== Hashes

When passing arrays as arguments, the array can be a list of hashes. The
following Playbook shows how an array with key-pair values is passed to the user module:
----
---
- name: Hash demo
  hosts: host1.example.com
  become: yes
  tasks:
    - name: Create users from hash
      user:
        name: "{{ item.name }}"
        state: present
        groups: "{{ item.groups }}"
      loop:
        - { name: 'jane', groups: 'wheel' }
        - { name: 'joe', groups: 'root' }
----

==== Nested Loops

A bit more complicated are nested loop. To get an idea of how they work here is an example you can run:
----
---
- name: Nested loop demo
  hosts: localhost
  become: no
  tasks:
    - name: Loop over the nested items
      shell: echo "nested test a={{ item[0] }} b={{ item[1] }} c={{ item[2] }}"
      loop: "{{ lookup('nested',
            [ 'red0', 'blue0' ],
            [ '1', '2', ],
            [ 'up', 'down' ]) }}"
----

TIP: There is a lot more you can do with Ansible loops: http://docs.ansible.com/ansible/playbooks_loops.html

=== Conditionals

Often the result of a play may depend on the value of a variable, fact, or previous task result. In some cases, the values of variables may depend on other variables. Or additional groups can be created to manage hosts based on whether the hosts match other criteria.

* Example: a conditional could be used to install a service only if a certain amount of memory is available.

==== Ansible *when* statement

To implement a conditional, the `when` statement is used, followed by the condition to test. The condition is expressed using one of the available operators like e.g. for comparison:

|===
|==|Compares two objects for equality.
|!=| Compares two objects for inequality.
|>|true if the left hand side is greater than the right hand side.
|>=|true if the left hand side is greater or equal to the right hand side.
|<|true if the left hand side is lower than the right hand side.
|< =|true if the left hand side is lower or equal to the right hand side.
|===

For more on this, please refer to the documentation: http://jinja.pocoo.org/docs/2.9/templates/

==== Conditionals Example

As an example you would like to install an FTP server, but only on hosts that are in the "ftpserver" inventory group.

As user ansible create this Playbook on control.example.com as `ftpserver.yml` in the `~/ansible-files/` directory, run it and examine the output:
----
---
- name: Install vsftpd on ftpservers
  hosts: all
  become: yes
  tasks:
    - name: Install FTP server when host in ftpserver group
      yum:
        name: vsftpd
        state: latest
      when: inventory_hostname in groups["ftpserver"]
----

TIP: The when statement must be placed "outside" of the module by being indented at the top level of the task.

Expected outcome: The task is skipped on host1.example.com because it is not in the ftpserver group in your inventory file:
----
[...]
TASK [Install FTP server when host in ftpserver group] *************************
skipping: [host1.example.com]
changed: [host2.example.com]
[...]
----

==== Challenge Lab: Fact in Conditional

Admittedly using an inventory group as a condition is the most basic case you would expect to just work. Let's try something a bit more interesting:

You might have noticed host1 and host2 have different amounts of RAM. If not have another look at the facts:
----
[ansible@control ansible-files]$ ansible all -m setup -a 'filter=ansible_*_mb'
----

Write a Playbook `mariadb.yml` that installs MariaDB but only if the host has more then, say, 3000 MB of RAM.

* Find the fact for memtotal in MB (look at the ad hoc command output and feel free to use "grep").
* Use this Playbook as a template and create the when statement by *replacing the upper case placeholders*:

WARNING: In a `when` statement facts and variables are *not* to be inclosed in double curly braces like you would do for variables!

----
---
- name: MariaDB server installation
  hosts: all
  become: yes
  tasks:
  - name: Install latest MariaDB server when host RAM greater 3000 MB
    yum:
      name: mariadb-server
      state: latest
    when: FACT COMPARISON_OPERATOR NUMBER
----

* Run the Playbook. As a result the installation task should be skipped on host2.

WARNING: *Solution below!*

----
---
- name: MariaDB server installation
  hosts: all
  become: yes
  tasks:
  - name: Install latest MariaDB server when host RAM greater 3000 MB
    yum:
      name: mariadb-server
      state: latest
    when: ansible_memtotal_mb > 3000
----


=== Ansible Handlers

Sometimes when a task does make a change to the system, a further task may need to be run. For example, a change to a service's configuration file may then require that the service be reloaded so that the changed configuration takes effect.

Here Ansible's handlers come into play. Handlers can be seen as inactive tasks that only get triggered when explicitly invoked using the "notify" statement.

As a an example, let's write a Playbook that:

* manages Apache's configuration file `httpd.conf` on all hosts in the `webserver` group
* restarts Apache when the file has changed

First we need the file Ansible will deploy, let's just take the one from control.example.com:
----
[ansible@control ansible-files]$ cp /etc/httpd/conf/httpd.conf .
----

Then create the Playbook `httpd_conf.yml`:

----
---
- name: manage httpd.conf
  hosts: webserver
  become: yes
  tasks:
  - name: Copy Apache configuration file
    copy:
      src: httpd.conf
      dest: /etc/httpd/conf/
    notify:
       - restart_apache
  handlers:
    - name: restart_apache
      service:
        name: httpd
        state: restarted
----

So what's new here?

* The "notify" section calls the handler only when the copy task changed the file.
* The "handlers" section defines a task that is only run on notification.

Run the Playbook. We didn't change anything in the file yet so there should not be any `changed` lines in the output and of course the handler shouldn't have fired.

* Now change the `Listen 80` line in httpd.conf to:
----
Listen 8080
----

* Run the Playbook again. Now the Ansible's output should be a lot more interesting:
** httpd.conf should have been copied over
** The handler should have restarted Apache

Apache should now listen on port 8080. Easy enough to verify:
----
[ansible@control ansible-files]$ curl http://host2.example.com

curl: (7) Failed connect to host2.example.com:80; Connection refused
----
----
[ansible@control ansible-files]$ curl http://host2.example.com:8080

<body>
<h1>This is a production webserver, take care!</h1>
</body>
----

Feel free to change the httpd.conf file again and run the Playbook.

=== Ansible Blocks

Ansible 2.0 added the "block" feature to allow for grouping of tasks and to help in play error handling. Most of what you can apply to a single task can be applied at the block level.

*Example*: Combined with a "when" conditional blocks can be used to execute a set of tasks with different parameters depending on operating system or memory size.

Create `block_example2.yml` and run it:

----
---
- hosts: all
  tasks:
    - block:
      - yum:
          name: httpd
          state: installed
      when: ansible_os_family == 'RedHat'
      become: yes

    - block:
      - apt:
          name: apache2
          state: installed
      when: ansible_os_family == 'Debian'
      become: yes
----

==== Blocks in Error Handling

Maybe even more important is the ability to use blocks for error handling, much like exceptions in programming. This is done by defining a main set of tasks and an extra set of tasks that will be only executed if the main set fails.

Here is a nice example for block error handling right from the Ansible documentation (It's not a complete Playbook, so don't try to run it as is):

[subs=+quotes]
----
  tasks:
   - name: Attempt and gracefull roll back demo
     *block*:
       - debug: msg='I execute normally'
       - command: /bin/false
       - debug: msg='I never execute, due to the above task failing'
     *rescue*:
       - debug: msg='I caught an error'
       - command: /bin/false
       - debug: msg='I also never execute :-('
     *always*:
       - debug: msg="this always executes"
----

* The tasks in the *block* would execute normally
* If there is any error (and there will because of the /bin/false command) the *rescue* section would get executed
* The *always* section runs no matter what previous error did or did not occur in the block and rescue sections.

==== Error Handling Lab

As an example of how blocks can help with error handling write a Playbook that:

* tries to activate an not-installed Apache module with apache2_module
* on fail stops Apache via rescue

Create the Playbook as `block_error.yml` and run it.

----
---
- name: Enable Apache2 module
  hosts: host1.example.com
  become: yes
  vars:
    apache_module: wsgi
  tasks:
  - block:
      - name: Enable Apache module
        apache2_module:
          state: present
          name: "{{apache_module}}"
    rescue:
      - name: rescue stop Apache
        service:
          name: httpd
          state: stopped
    always:
      - debug:
          msg: >
            "This is always executed"
----

Expected outcome:

* The *block* with the apache2_module task fails
* The *rescue* task is executed and Apache gets stopped
* The *always* task is executed

Why not go and check that Apache is actually stopped using an quick ad hoc command? Just to stay busy? :-)

== Ansible Templates

Ansible uses Jinja2 templating to modify files before they are distributed to managed
hosts. Jinja2 is a templating language for Python with a wealth of features. In the context of Ansible loops and conditionals can be used in templates, but probably the most common use is to reference variables which get replaced with the values of facts.

=== Using Templates in Playbooks

When a template for a file has been created, it can be deployed to the managed hosts using the `template` module, which supports the transfer of a local file from the control node to the managed hosts.

As an example of using templates you will change the motd file to contain host-specific data.

In the `~/ansible-files/` directory on control.example.com as user ansible create the template file `motd-facts.j2`:
----
Welcome to {{ ansible_hostname }}.
{{ ansible_distribution }} {{ ansible_distribution_version}}
deployed on {{ ansible_architecture }} architecture.
----

In the `~/ansible-files/` directory on control.example.com as user ansible create the Playbook `motd-facts.yml`:
----
---
- name: Fill motd file with host data
  hosts: host1.example.com
  become: yes
  tasks:
    - template:
        src: motd-facts.j2
        dest: /etc/motd
        owner: root
        group: root
        mode: 0644
----

You have done this a couple of times by now:

* Understand what the Playbook does.
* Execute the Playbook `motd-facts.yml`
* Login to host1.example.com via SSH and check the motto of the day message.
* Log out of host1.example.com

You should see how Ansible replaces the variables with the facts it discovered from the system.

=== Challenge Lab: Templates

Change the template to use the FQDN hostname:

* Find a fact that contains the fully qualified hostname using the commands you learned in the "Ansible Facts" chapter.

TIP: Do a `grep -i` for fqdn

* Change the template to use the fact you found.
* Run the Playbook again.
* Check motd by logging in to host1.example.com

WARNING: *Solution below!*

* Find the fact:
----
[ansible@control ansible-files]$ ansible host1.example.com -m setup | grep -i fqdn
----

* Use the `ansible_fqdn` fact in the template `motd-facts.j2`.

=== Advanced Templates

As mentioned Jinja2 supports a lot more then just referencing variables. The following template showcases some of these advanced features.

* *ansible_managed* is a special variable that can be added to a file by a template to show this file was created by ansible.
* You can lookup values for other hosts
* You can loop over values, e.g. over all hosts in an Ansible groups

----
### {{ ansible_managed }}

### My host name
My non-FQDN hostname is {{ ansible_hostname }}.

### Where host2 is
Host2 IP is: {{ hostvars['host2.example.com']['ansible_default_ipv4']['address'] }}

### What else is here?
The machines in group webserver are:
{% for host in groups['webserver'] %}
- {{ hostvars[host]['inventory_hostname'] }}

{% if host | match('host1.example.com') %}
host1.example.com MEM: {{ ansible_memfree_mb }}
{% endif %}
{% endfor %}

We also support external lookups: {{ lookup('dig', 'redhat.com./MX') }}
----

* Create this template as `advanced_template.j2` on control.example.com.
* Create a Playbook to test it:
----
---
- name: advanced template test
  hosts: all
  tasks:
  - name: template vhost file
    template:
      src: advanced_template.j2
      dest: /home/ansible/advanced_template.out
      owner: ansible
      group: ansible
      mode: 0644
----

* Run the Playbook
* Use an Ansible ad hoc command to have a look at the output file.

== Ansible Inclusions & Roles

=== Structuring Ansible Playbooks with includes and roles

While it is possible to write a Playbook in one very large file, eventually you’ll want to reuse files and start to organize things. At a basic level, including task files allows you to break up bits of configuration policy into smaller files. Task includes pull in tasks from other files. Since handlers are tasks too, you can also include handler files.

When you start to think about it – tasks, handlers, variables, and so on – begin to form larger concepts. You start to think about modeling what something is,

* It’s no longer "apply THIS to these hosts"
* You say "these hosts are dbservers" or "these hosts are webservers".

Roles build on the idea of include files and provide Ansible with a way to load tasks, handlers, and variables from external files. The files that define a role have specific names and are organized in a rigid directory structure.

Use of Ansible roles has the following benefits:

* Roles group content, allowing easy sharing of code with others
* Roles can be written that define the essential elements of a system type: web server, database
server...
* Roles make larger projects more manageable
* Roles can be developed in parallel by different administrators

TIP: We’ll start with understanding includes so roles make more sense, but our ultimate goal should be understanding roles – roles are great and you should use them every time you write Playbooks.

=== Ansible Inclusions

Tasks can be included in a Playbook from an external file by using the include directive.
----
tasks:
  - name: Include tasks to install the database server
    include: tasks/db_server.yml
----

The include_vars module can include variables defined in either JSON or YAML files,
overriding host variables and Playbook variables already defined.
----
tasks:
  - name: Include the variables from a YAML or JSON file
    include_vars: vars/variables.yml
----

==== Lab: Inclusions

Define the `paths.yml` variables file that sets some system paths and uses a fact.
----
---
paths:
  fileserver: /home/ansible/srv/filer/{{ ansible_fqdn }}
  dbpath: /home/ansible/srv/database/{{ ansible_fqdn }}
----

Create the `fileservers.yml` Playbook and include the `paths.yml` variables file. The
fileserver structure will be created using the variable defined previously in the `paths.yml`
variables file.
----
---
- hosts: webserver
  tasks:
  - name: Imports the variables file
    include_vars: paths.yml
  - name: Creates the remote directory
    file:
      path: "{{ paths.fileserver }}"
      state: directory
      mode: 0755
    register: result
  - name: Debugs the results
    debug:
      var: result
----

Run the `fileservers.yml` Playbook and examine the output.

The output shows the directory structure that has been created by Ansible, which matches
the path that has been set by the paths.fileserver variable.

==== Challenge Lab

Well, not that much of a challenge, just to keep you busy. Create a new Playbook `dbservers.yml` that does the same like above but this time using the "paths.dbpath" variable.

WARNING: *Solution Below*

----
---
- hosts: database
  tasks:
  - name: Imports the variables file
    include_vars: paths.yml
  - name: Creates the remote directory
    file:
      path: "{{ paths.dbpath }}"
      state: directory
      mode: 0755
    register: result
  - name: Debugs the results
    debug:
      var: result
----

=== Working with Roles

==== Ansible Role Structure

Roles are basically automation around *include* directives as described above, and really don’t contain much additional magic beyond some improvements to search path handling for referenced files.

Roles follow a defined directory structure, a role is named by the top level directory. Some of the subdirectories contain YAML files, named `main.yml`. The files and templates subdirectories can contain objects referenced by the YAML files.

An example project structure could look like this, the name of the role would be "user":
----
user/
├── defaults
│   └── main.yml
├── files
├── handlers
│   └── main.yml
├── meta
│   └── main.yml
├── README.md
├── tasks
│   └── main.yml
├── templates
├── tests
│   ├── inventory
│   └── test.yml
└── vars
    └── main.yml
----

==== Using Variables and Defaults in Roles

Role variables are defined by creating a `vars/main.yml` file. They are referenced in the role YAML file like any other variable: `{{ var }}`.

TIP: These variables have a high priority and can not be overridden by inventory
variables.

Default variables allow default values to be set for variables of included or dependent roles. They are defined by creating a `defaults/main.yml`.

TIP: Default variables have the lowest priority of any variable. They can be overridden by other variable.

TIP: Define a specific variable in either `vars/main.yml` or `defaults/main.yml`, but not in both
places. Default variables should be used when it is intended that their values will be overridden.

==== Using Roles in a Playbook

Using roles in a Playbook is straight forward:
----
---
- hosts: remote.example.com
  roles:
    - role1
    - role2
----

For each role, the role tasks, role handlers, role variables, and role dependencies will be included in the Playbook, in that order. Any copy, script, template, or include tasks in the
role can reference the relevant files, templates, or tasks *without absolute or relative path names*. Ansible will look for them in the role's files, templates, or tasks respectively, based on their
use.

==== Lab: Roles

Ansible looks for roles in a subdirectory called `roles` in the project directory. This can be overridden in the Ansible configuration. Each role has its own directory. To ease creation of a new role the tool `ansible-galaxy` can be used.

TIP: Ansible Galaxy is your hub for finding, reusing and sharing the best Ansible content. `ansible-galaxy` helps to interact with Ansible Galaxy. For now we'll just using it as a helper to build the directory structure.

Okay, lets start to build a role. We'll build a role that installs and configures Apache to serve a virtual host. Run these commands in your "ansible-files" directory:
----
[ansible@control ansible-files]$ mkdir roles
[ansible@control ansible-files]$ ansible-galaxy init --offline roles/apache_vhost
----

Have a look at the role directories and their content (first install `tree` as root):
----
[root@control ~]# yum -y install tree
[root@control ~]# su - ansible
[ansible@control ~]$ cd ansible-files
[ansible@control ansible-files]$ tree roles
----

===== Create the tasks file

The `main.yml` file in the tasks subdirectory of the role should do the following:

* Make sure httpd is installed
* Make sure httpd is started and enabled
* Put HTML content into the Apache document root
* Install the template provided to configure the vhost

WARNING: The `main.yml` (and other files possibly included by main.yml) can only contain tasks, *not* complete Playbooks!

TIP: Some of these tasks have been done in other parts of the lab, don't worry, it's about the learning experience... ;-)

You have already learned about the modules and how to use them, so try to get the tasks file done alone. With some hints from your friendly lab guide. ;-)

Edit the `tasks/main.yml` file
----
[ansible@control ansible-files]$ vi roles/apache_vhost/tasks/main.yml
----

The structure of the file should be like this, you will have to fill in the BLANKs:
----
---
# tasks file for setting up Apache vhost
- name: install httpd
<BLANK>

- name: start and enable httpd service
<BLANK>

- name: deliver html content
<BLANK>

- name: template vhost file
<BLANK>
----

Add the instructions needed to:

* Install the httpd package using the yum module
* Use the service module to enable and start httpd
* Make sure the needed directory structure exists (`/var/www/vhosts/{{ ansible_hostname }}`)
** Hint: Use the `file` module)
* Use the copy module to copy HTML from the role to the vhost DocumentRoot, example:
----
src: html/index.html
dest: "/var/www/vhosts/{{ ansible_hostname }}"
----

* Use the template module to create the vhost configuration file from a j2-template, hints:
----
  src: vhost.conf.j2
  dest: /etc/httpd/conf.d/vhost.conf
  owner: root
  group: root
  mode: 0644
notify:
  - restart_httpd
----

Note it is using a handler to restart httpd after an confguration update.

WARNING: Do not forget this is just the tasks and not a complete Playbook!

*The solution for the tasks file can be found below*

===== Create the handler

Create the handler in the file `handlers/main.yml` to restart httpd when notified by the template task:
----
---
# handlers file for apache_vhost
- name: restart_httpd
  service:
    name: httpd
    state: restarted
----

===== Create the index.html and vhost configuration file template

Create the HTML content that will be served by the webserver.

* The role task that called the copy module referred to an html directory "src/". Create this directory below the files subdirectory of the role:
----
[ansible@control ansible-files]$ mkdir roles/apache_vhost/files/html
----

* Create an index.html file in the "src" directory:
----
[ansible@control ansible-files]$ echo 'simple vhost index' > roles/apache_vhost/files/html/index.html
----

* Create the `vhost.conf.j2` template file in the role's templates subdirectory.
----
# {{ ansible_managed }}

<VirtualHost *:8080>
    ServerAdmin webmaster@{{ ansible_fqdn }}
    ServerName {{ ansible_fqdn }}
    ErrorLog logs/{{ ansible_hostname }}-error.log
    CustomLog logs/{{ ansible_hostname }}-common.log common
    DocumentRoot /var/www/vhosts/{{ ansible_hostname }}/

    <Directory /var/www/vhosts/{{ ansible_hostname }}/>
	Options +Indexes +FollowSymlinks +Includes
	Order allow,deny
	Allow from all
    </Directory>
</VirtualHost>
----

===== Test the role

You are ready to test the role against host2.example.com. First create the following Playbook as `test_apache_role.yml`:
----
---
- name: use apache_vhost role playbook
  hosts: host2.example.com
  become: yes

  pre_tasks:
    - debug:
        msg: 'Beginning web server configuration.'

  roles:
    - apache_vhost

  post_tasks:
    - debug:
        msg: 'Web server has been configured.'
----

TIP: Note the pre_tasks and post_tasks tasks. Normally, the tasks of roles execute before the tasks of the Playbook. To control order of execution pre_tasks tasks are performed before any roles are applied. The post_tasks tasks are performed after all the roles have completed.

Now you are ready to run your Playbook:
----
[ansible@control ansible-files]$ ansible-playbook test_apache_role.yml
----

Run ad hoc commands to confirm that the role worked:
----
[ansible@control ansible-files]$ ansible host2.example.com -a 'yum list installed httpd'
[ansible@control ansible-files]$ ansible host2.example.com -a 'cat /etc/httpd/conf.d/vhost.conf'
[ansible@control ansible-files]$ ansible host2.example.com -a 'cat /var/www/vhosts/host2/index.html'
[ansible@control ansible-files]$ curl -s http://host2.example.com:8080
----

All looking good? Congratulations!

WARNING: *Solution Below!*

----
[ansible@control ansible-files]$ cat roles/apache_vhost/tasks/main.yml
---
# tasks file for setting up Apache vhost
- name: install httpd
  yum:
    name: httpd
    state: latest

- name: start and enable httpd service
  service:
    name: httpd
    state: started
    enabled: true

- name: deliver html content
  copy:
    src: html/
    dest: "/var/www/vhosts/{{ ansible_hostname }}"

- name: template vhost file
  template:
    src: vhost.conf.j2
    dest: /etc/httpd/conf.d/vhost.conf
    owner: root
    group: root
    mode: 0644
  notify:
    - restart_httpd
----

== Troubleshooting and Debugging Ansible

=== Debug module

You have used the Ansible debug module in some lab tasks already. It can provide the value for a certain variable at Playbook execution time.

The following examples show the use of the msg statement inside of the debug statement:

----
---
- name: test debug
  hosts: localhost
  gather_facts: yes
  vars:
    - myvar: variable_content

  tasks:
    - name: output myvar
      debug:
        msg: "myvar: {{ myvar }}"
    - name: output myvar only at higher verbosity
      debug:
        msg: "myvar verbosity 2 {{ myvar }}"
        verbosity: 2
    - name: output fact
      debug:
        msg="The free memory for this system is {{ ansible_memfree_mb }}"
----

Create and run the Playbook as `debug.yml`. The way we call the Playbook here is useful for testing purposes because we don't need an inventory:

----
[ansible@control ~]$ ansible-playbook -i localhost, -c local debug.yml
----

Now set the verbosity to "2" to see the additional output:

----
[ansible@control ~]$ ansible-playbook -i localhost, -c local debug.yml -vv
----


=== Playbook Errors

Getting errors from Playbooks at execution time will happen frequently to you, mostly because of syntax errors in Playbooks or templates or network connectivity issues. To help with finding errors there are a couple of options:

Have Ansible step through the tasks interactively:
----
[ansible@control ansible-files]$ ansible-playbook debug.yml --step
----

Start execution from a given task:
----
[ansible@control ansible-files]$ ansible-playbook apache.yml --start-at-task="Apache enabled and running"
----

Check the syntax of a Playbook:
----
[ansible@control ansible-files]$ ansible-playbook apache.yml --syntax-check
----

=== Keeping Ansible Files on Host

When Ansible executes a command on a remote host, usually a Python script is copied, executed and removed immediately. However, for debugging it might make sense to keep the script and execute it locally. Ansible can be persuaded to keep a script by setting the variable ANSIBLE_KEEP_REMOTE_FILES to true at the command line:

----
[ansible@control ansible-files]$ ANSIBLE_KEEP_REMOTE_FILES=1 ansible-playbook apache.yml -vvv
----

----
[ansible@host1]$ python /home/ansible/.ansible/tmp/ansible-tmp-<id>/command
----

=== Recommended Practices for Playbooks

Although the previously discussed tools can help to identify and fix issues in Playbooks, when
developing Playbooks it is important to keep in mind some recommended practices for Playbook development:

* Always name tasks, providing a description of the task's purpose.
* Include comments to add additional inline documentation about tasks.
* Make use of vertical whitespace effectively. YAML syntax is mostly based on spaces, so avoid
the usage of tabs in order to avoid errors.
* Try to keep the Playbook as simple as possible. Only use the features that you need.

== The End

Congratulations, you finished your labs! We hope you enjoyed your first steps using Ansible as much as we enjoyed creating the labs.

But it doesn't have to end here. We prepared some more bonus labs for you to follow through if you like.

== Bonus Labs

Here are some more labs for you:

=== Bonus Lab: Ad Hoc Commands

* Create a new user "testuser" on host1 and host2 using an ad hoc command
** Find the parameters for the appropriate module using `ansible-doc user` (leave with `q`)
** Use an Ansible ad hoc command to create the user with the comment "Test D User"
** Use the "command" module with the proper invocation to find the userid

* Delete the user and check it has been deleted

TIP: Remember privilege escalation...

WARNING: *Solution below!*

Your commands could look like these:
----
[ansible@control ansible-files]$ ansible-doc -l | grep -i user
[ansible@control ansible-files]$ ansible-doc user
[ansible@control ansible-files]$ ansible all -m user -a "name=testuser comment='Test D User'" -b
[ansible@control ansible-files]$ ansible all -m command -a " id testuser" -b
[ansible@control ansible-files]$ ansible all -m user -a "name=testuser state=absent remove=yes" -b
[ansible@control ansible-files]$ ansible all -m command -a " id testuser" -b
----

=== Bonus Lab: Templates and Variables

You have learned the basics about Ansible templates, variables and handlers. Let's combine all of these.

Instead of editing and copying `httpd.conf` why don't you just define a variable for the listen port and use it in a template? Here is your job:

* Define a variable "listen_port" for the `webserver` group with the value "80" and another for `host2.example.com` with the value "8080" using the proper files. Utilize the `group_vars` and `host_vars` directories. Refer to the chapter "Ansible Variables".

TIP: Right now `host2.example.com` should be serving a vhost on port 8080 and we would like to keep it there.

* Copy the `httpd.conf` file into the template `httpd.conf.j2` that uses the `listen_port` variable instead of the hard-coded port number.
* Write a Playbook that deploys the template and restarts Apache on changes using a handler.
* Run the Playbook and test the result using "curl".

WARNING: *Solution below!*

==== Define the variables:

* Add this line to `group_vars/webserver`:
----
listen_port: 80
----

* Add this line to `host_vars/host2.example.com`:
----
listen_port: 8080
----

==== Prepare the template:

* Copy `httpd.conf` to `httpd.conf.j2`
* Edit the "Listen" directive in `httpd.conf.j2` to make it look like this:
----
[...]
Listen {{ listen_port }}
[...]
----

==== Create the Playbook `apache_config_tpl.yml`:

----
---
- name: Apache httpd.conf
  hosts: webserver
  become: yes
  tasks:
  - name: Create Apache configuration file from template
    template:
      src: httpd.conf.j2
      dest: /etc/httpd/conf/httpd.conf
    notify:
       - restart apache
  handlers:
    - name: restart apache
      service:
        name: httpd
        state: restarted
----

==== Run and test:
----
[ansible@control ansible-files]$ ansible-playbook apache_config_tpl.yml
----
----
[ansible@control ansible-files]$ curl http://host2.example.com:8080
simple vhost index
----
----
[ansible@control ansible-files]$ curl http://host1.example.com:80
<body>
<h1>This is a development webserver, have fun!</h1>
</body>
----

TIP: Output might vary depending if you run the command in "Keeping Ansible Files on Host".

=== Bonus Lab: Change a Configuration File

This lab is about how to automate a pretty common sys admin task: Make sure a configuration file setting is configured in a certain way. As an example let's make sure the SSH daemon is not accepting direct root logins.

You'll need to learn about a new module; `lineinfile`. Here is your job:

* Read the `lineinfile` doc
* Copy `apache_config_tpl.yml` to `no_sshd_root.yml` and adapt it to:
** Use the module `lineinfile` with these parameters:
*** Use the `dest` option to specify the config file (`/etc/ssh/sshd_config`)
*** Use the `line` option to provide the proper config file value (use `"PermitRootLogin no"`)
* Configure a handler `restart_sshd` to restart `sshd` when the configuration was changed.
* Test the SSH login as root, the password is the same as for everything else.

WARNING: *Solution below!*

* Create the Playbook `no_sshd_root.yml`

----
---
- name: no root login to sshd
  hosts: all
  become: yes
  tasks:
  - name: change sshd config file
    lineinfile:
      dest: /etc/ssh/sshd_config
      line: "PermitRootLogin no"
    notify:
       - restart_ssh
  handlers:
    - name: restart_ssh
      service:
        name: sshd
        state: restarted
----

* Run it and check the SSH login as root:

----
[ansible@control ansible-files]$ ansible-playbook no_sshd_root.yml
----
----
[ansible@control ansible-files]$ ssh root@host1.example.com
root@host1.example.com's password:
Permission denied, please try again.
----
